import{j as e}from"./index-L2rlbWB0.js";function s(){return e.jsxs("article",{className:"article",children:[e.jsx("h2",{children:"Top 5 Accessibility Errors"}),e.jsx("p",{children:"Accessibility is the foundation of usable design. If your app only works for some users, it isn’t a complete interface... it’s a broken one. When accessibility fails, real people get locked out. Blind users can’t navigate. Keyboard users get stuck. Poor contrast makes content unreadable. These are barriers that block real users."}),e.jsx("p",{children:"This post breaks down five of the most common accessibility issues in modern web apps. They’re easy to miss... but just as easy to fix. Addressing them makes your interface usable for more people."}),e.jsx("h3",{children:"1. Images without alt text"}),e.jsx("p",{children:"It’s an easy mistake with serious consequences. Adding an image without alt text means screen readers have nothing to announce. For blind users, the content is invisible."}),e.jsx("p",{children:"Who it affects:"}),e.jsx("p",{children:"Blind users and screen reader users."}),e.jsx("p",{children:"How to detect:"}),e.jsx("p",{children:"Check for missing or empty alt attributes on <img> tags and unlabeled icons/buttons."}),e.jsx("p",{children:"How to fix:"}),e.jsx("p",{children:"Add clear, concise alt text to images. Use aria-label, aria-labelledby, or visible text for interactive elements."}),e.jsx("h3",{children:"2. Reactivity Without Boilerplate"}),e.jsx("p",{children:"Vue is a compiled framework, so this comes with an admitted caveat. React 19 will be compiled, and it, too, has reduced boilerplate. In Vue, using ref, reactive, and computed, you get automatic updates when your data changes. There is no need for state setters or dependency arrays. Vue tracks dependencies for you, leading to cleaner and more maintainable code."}),e.jsx("p",{children:"Additionally, these operate outside of a Vue template. You can import them into your code and use them. That's a cool feature. While React has custom hooks, they still come with structural rules and boilerplate. That's not the case with Vue. Fair warning: because Vue uses proxies, its reactivity is different from React's. Proceed with caution when under its hood."}),e.jsx("h3",{children:"1. Provide/Inject for Scoped Dependency Sharing"}),e.jsx("p",{children:"Vue’s directives like v-if, v-for, and v-bind keep logic declarative and markup readable. Conditional rendering and list generation feel native, not engineered. Custom directives take this further. They let you wrap low-level DOM behavior, like auto-focus, scroll locks, and tooltips, into one reusable interface."}),e.jsx("p",{children:"In React, the equivalent often involves hooks, extra components, or both. It works—but it’s more ceremony for the same result."}),e.jsx("p",{children:"I love ternaries, but I hate when people nest them. For some perplexing reason, some people think it's okay to do that in React. It's not. It never is. There are ways to do clean conditional rendering in React. But it requires some level of thought, effort, or know-how. Directives like 'v-if', 'v-for', and 'v-bind' make it easy. And makes HTML feel... like HTML. Custom directives let you combine complex DOM behavior into one reusable hook."}),e.jsx("p",{children:"This also makes nesting ternaries in HTML impossible... just putting that out there."}),e.jsx("h3",{children:"Template-Driven Composition"}),e.jsx("p",{children:"JSX is powerful because it allows you to mix logic and markup. But it can also feel directionless due to that. Of course, you should separate business and reusable logic into hooks. But that has its own downsides: file bloat being chief among them. Vue’s template syntax and Composition API work together to solve this problem. Separating business and rendering logic keeps both layers clean and reduces the friction of scaling a component."}),e.jsx("h3",{children:"CSS and Scoped styles"}),e.jsx("p",{children:"Tailwind has made utility-first styling the default in many teams. But scoped styles still matter, and Vue supports them out of the box. It matters a lot where utility classes fall short. This includes named CSS grids, complex media queries, and component libraries."}),e.jsxs("p",{children:["Furthermore, scoped CSS gives you true style encapsulation with no extra tooling. Add the scoped attribute to your ","<style>"," ","block, and Vue handles the rest. Styles apply only to their own component. This limits global bleed and prevents class name collisions."]}),e.jsx("h3",{children:"Conclusion"}),e.jsx("p",{children:"Framework loyalty is common. But it can be limiting. Vue and React take different approaches to solving real-world UI problems. And Vue has a few elegant solutions worth studying. Vue presents fresh concepts that can change how you think about reactivity, separation of concerns, and developer ergonomics, even if you work with React every day. Good engineers know their tools. Great engineers know the alternatives."})]})}export{s as default};
